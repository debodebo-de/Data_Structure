{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2023-04-22T21:09:37.166Z","updated":"2023-04-22T21:09:37.166Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"你好呀！ 我是一名大二java开发爱好者，blog小白，正在疯狂学习java开发知识以及摸索blog功能中！希望在实习前能够多学一点后端知识，让自己更有底气！ 如今就业形式严峻，且我不想考研，愿自己多看书，多动脑，找到令自己满意的工作！ 与君共勉！ 联系方式 Email: &#x6f;&#109;&#x6f;&#x75;&#101;&#x6d;&#x6f;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109; 微信：kfcvwo50- GitHub：debodebo-de"}],"posts":[{"title":"","slug":"java基础到面向对象","date":"2023-04-22T21:18:22.170Z","updated":"2023-04-21T11:20:28.496Z","comments":true,"path":"2023/04/23/java基础到面向对象/","link":"","permalink":"http://example.com/2023/04/23/java%E5%9F%BA%E7%A1%80%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"JAVAIDEA debug 基础调试技能 断点在需要停留的代码位置打个标示，程序运行到这个地方会暂停 开启调试模式 step over：程序向下执行一行 step into ：进入自定义方法 step out ：跳出对应的方法 JAVA注释使用1//这个是单行注释 12345/* *这个是多行注释 * * */ 12345/** *这个是文档注释，描述类的作用 *@author 噢噢 *@version 1.0.0 */ JAVA模块和划分包的使用 格式规范包名：全部小写字母，可以是域名反过来写 怎样导入其他包 import关键词导入其他包下的类eg：导入工具类包 123456//导入util包下的Date类import java.util.Date; //*号表示这个util包下面的类全都导入进来import java.util.*; JAVA核心基础知识之修饰符 访问修饰符： 限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符 private &lt; default &lt;protected &lt; public 非访问修饰符：用来修饰或者辅助功能 主要记住： 外部类修饰符：public或者默认 方法、属性类修饰符：private、default、protected、public public - 公开对外部可见 protected - 对所有包和所有子类可见 private- 仅对内部可见 方法（属性）级别 修饰府 当前类 同一包内 不同包中的子类 不同包中的非子类 public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N 属性或者成员变量，都用必须用private修饰 1.变量与数据类型1.1什么是变量1.变量是内存中的一块存储区域2.变量是用来存数据的 1.2使用变量java是一个强类型的语言： 12强类型语言也称为强类型定义语言。是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用 1.java中的变量必须先声明，后使用 java中声明变量的语法 123456789//变量类型 变量名=数据 如int num=18//也可以先声明，再赋值int numnum=18//也可以同时声明多个int d = 3, e = 4, f = 5;//注意只声明不赋值，使用的时候会报错，因为变量没有默认值//变量不允许重复声明 1.3变量的分类Java 中主要有如下几种类型的变量 局部变量 类变量（静态变量） 成员变量（实例变量） 成员变量、局部变量、静态变量的区别 成员变量 局部变量 静态变量 定义位置 在类中,方法外 方法中,或者方法的形式参数 在类中,方法外 初始化值 有默认初始化值 无,先定义,赋值后才能使用 有默认初始化值 调用方式 对象调用 — 对象调用，类名调用 存储位置 堆中 栈中 方法区 生命周期 与对象共存亡 与方法共存亡 与类共存亡 别名 实例变量 — 类变量 2.数据类型2.1数据类型汇总按照数据类型来分 ​ 基本数据类型：一共有八个，六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 ​ （1）数字类型​ 整数类型：byte， short， int，long​ 浮点类型：float，double​ （2）字符类型：char​ （3）布尔类型：boolean ​ 引用数据类型：类（class） 接口(interface) 数组([]) 2.2整数类型1234561 GB = 1024 MB，GB：千兆1 MB = 1024 KB，MB：兆1 KB = 1024 B，KB：千字节，B 是 Byte 的缩写，即字节1 Byte = 8 Bit。Bit——Binary Digit（二进制数位）的缩写，叫作“位”或“比特”，是计算机运算的基础。Bit 代表二进制数位，取值范围为：0 或 1。 byte： byte 数据类型是8位(1个字节大小)、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a &#x3D; 100，byte b &#x3D; -50。 1byte a=128;//error 因为byte最大值是127 short： short 数据类型是 16 位（2个字节大小）、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s &#x3D; 1000，short r &#x3D; -20000。 int：最最常用的整数类型 int 数据类型是32位（4个字节大小）、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a &#x3D; 100000, int b &#x3D; -200000。 long： long型变量必须以大写L结尾 long 数据类型是 64 位（8个字节大小）、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a &#x3D; 100000L，long b &#x3D; -200000L。 2.3 浮点型float：float型变量必须以大写F或者小写f结尾 float 数据类型是单精度、32位（4个字节大小）、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 范围：-3.40E+38 ~ +3.40E+38 E表示10的多少次方的意思（float 类型可最大表示3.4x10^38） 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 &#x3D; 234.5f。 double： double 数据类型是双精度、64 位（8个字节大小）、符合 IEEE 754 标准的浮点数； 浮点数的默认类型为 double 类型； 范围：-1.79E+308 ~ +1.79E+308 精度正好是float的两倍，所以叫双精度 double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子： double a&#x3D;2.5 2.4 字符型char：注意要写在单引号里,不是双引号 char 类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（十进制等效值为 0）； 最大值是 \\uffff（即为 65535）； char 数据类型可以储存任何字符； 例子：char letter &#x3D; ‘A’;。 取值范围大写字母（A-Z）：65 （A）~ 90（Z）小写字母（a-z）：97（a） ~ 122（z）字符数字（’0’ ~ ‘9’）：48（’0’） ~ 57（’9’） 12char类型是可以运算的因为char在ASCII等字符编码表中有对应的数值。在JAVA中，对char类型字符运行时，直接当做ASCII表对应的整数来对待。 2.5布尔型布尔只有两个值 true或者false 3.数据类型转换3.1自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。也就是说小的数据可以转成大的，因为大的取值范围一定包含小的值的取值范围 12低 ------------------------------------&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型 同样float数据类型的位数为32，可以自动转换为64位的double类型。 3.2强制类型转换将容量大的转成容量小的，例如将double转成int 例如 12double a=12.5;int b=a;//error 不兼容的类型: 从double转换到int可能会有损失 这样直接赋值会报错，所以需要强制转换 语法 1(type)value 重新运行 1234double a=12.5;int b=(int)a;System.out.println(b);//12 注意，只取整数部分，哪怕是12.9也是12//这种情况可能会损失精度 但是也不是说所有情况都会损失精度，例如 12int i1 = 123;byte b = (byte)i1;//强制类型转换为byte 123 还有一种特殊情况： 123int a=128;byte b=(byte)a;System.out.println(b);//-128 为什么结果式-128呢？，因为byte中127后一位就是-128，理解为时钟的效果就可以 4.运算符4.1算术运算符一般：+ - * &#x2F; % 操作符 描述 例子 ++ 自增: 操作数的值增加1 B++ 或 ++B 等于 21（区别详见下文） – 自减: 操作数的值减少1 B– 或 –B 等于 19（区别详见下文） 特殊的，关于++和–，放在前后不一样 121、前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。2、后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算 4.2赋值运算符例如：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; （%）&#x3D; 注意： C + &#x3D; A 与 C &#x3D; C + A 是有区别的一句话总结： +&#x3D; 运算符既可以实现运算，又不会更改 s 的数据类型；而后者，C 和 A 必须是同一类型，否则无法直接运算。 4.3关系运算符例如：&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; 注意：比较字符串 字符串.equals(字符串) 4.4逻辑运算符例如：&amp;&amp;（与） ||（或） !（非） 注意： &amp;&amp; 和 || 进行运算时有短路性 4.5三元运算符语法如下： 1variable x = (expression) ? value if true : value if false 示例： 1234int a = 5;int b=6;int c=a&gt;b?a:b;System.out.println(c);//6 4.6运算符优先级下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 expr++ expr– 从左到右 一元 ++expr –expr + - ～ ！ 从右到左 乘性 * &#x2F;％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 左到右 相等 &#x3D;&#x3D; !&#x3D; 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 || 左到右 条件 ？： 从右到左 赋值 &#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; |&#x3D; 从右到左 逗号 ， 左到右 4.7 instaceofa instance of b 判断a对象是否是b对象的实例 5.scanner类scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 我们要使用他就必须导入，这个包是由系统提供的，我们装jdk的时候就已经装好了 123456789101112//1.导包import java.util.Scanner;public class Demo &#123;public static void main(String[] args)&#123;//2.创建一个scanner对象Scanner scan = new Scanner(System.in);//从键盘接收数据//3.nextInt方法接收一个数字int a=scan.nextInt();System.out.println(a);&#125;&#125;//此时就可以终端输入了 上面我们通过nextInt接受一个数字，如果需要接受字符串，布尔等也是可以的 小demo 12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 int i = 0; float f = 0.0f; System.out.print(&quot;输入整数：&quot;); if (scan.hasNextInt()) &#123; // 判断输入的是否是整数 //获取字符串是next()方法 i = scan.nextInt(); // 接收整数 System.out.println(&quot;整数数据：&quot; + i); &#125; else &#123; // 输入错误的信息 System.out.println(&quot;输入的不是整数！&quot;); &#125; System.out.print(&quot;输入小数：&quot;); if (scan.hasNextFloat()) &#123; // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(&quot;小数数据：&quot; + f); &#125; else &#123; // 输入错误的信息 System.out.println(&quot;输入的不是小数！&quot;); &#125; scan.close(); &#125;&#125; 6.流程控制6.1if else语法 1234567if(布尔值)&#123; //代码&#125;else if(布尔值)&#123; //代码&#125;else&#123; //代码&#125; 6.2 switch case语法 1234567891011switch(expression)&#123; case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句&#125; switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。也就是说switch()里放布尔值都是不可以的 注意：如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。(也就是说匹配成功之后，后面就不判断条件，后面的全都执行) 6.3 循环结构定义：程序反复运行一套代码，这就叫循环 Java中有三种主要的循环结构： while 循环 do…while 循环 for 循环 6.3.1 while循环语法： 123while( 布尔表达式 ) &#123; //循环内容&#125; 例如： 123456789public class Demo &#123; public static void main(String[] args)&#123; int a=0; while(a&lt;10)&#123; a++; System.out.println(&quot;执行了一次&quot;); &#125; &#125;&#125; 6.3.2 do while循环do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 语法 123do &#123; //代码语句&#125;while(布尔表达式); 例如 123456int a=11;do&#123; a++; System.out.println(&quot;哈哈&quot;); &#125; while(a&gt;15);//哪怕条件不成立，也是会执行 6.3.3 for循环语法 123for(初始化; 布尔表达式; 更新) &#123; //代码语句&#125; 6.3.4 break和continuebreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。 7.数组7.1 什么是数组：数组是用来存储固定大小的同类型元素数组存放是不限制数据类型的可以是int 可以是 double甚至可以是自定义类 7.2 声明数组语法： 1234567dataType[] arrayRefVar; // 首选的方法例如：double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;;或dataType arrayRefVar[]; // 效果相同，但不是首选方法例如：double myList[] = &#123;1.9, 2.9, 3.4, 3.5&#125;; 7.3数组初始化1.静态初始化 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 如： 123456int[] numList=&#123;1,2,3,4,5&#125;;或者int[] numList=new int[]&#123;1,2,3,4,5&#125;但是注意，如下写法不行,因为在一行写默认有类型推断不会报错，换行写无法推断int numListnumList=&#123;1,2,3,4,5&#125;; //error 2.动态初始化 1dataType[] arrayRefVar = new dataType[arraySize]; 如： 1int[] numList=new int[8]; 7.4数组的访问数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 array.length-1。 更改数组直接通过： 数组名[索引]&#x3D;”值” 注意：下面这种会出现数组角标越界的错误 1234int[] numList=new int[2];numList[0]=1;numList[1]=2;numList[2]=3;//error ArrayIndexOutOfBoundsException 因为内容超出了数组的长度范围 特殊的，JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组 语法： 1234for(type element: array)&#123; System.out.println(element);&#125; 12345678910public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (double element: myList) &#123; System.out.println(element); &#125; &#125;&#125; 7.5 二维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组 语法： type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。 语法：(动态初始化) 1type[][] typeName = new type[typeLength1][typeLength2]; ​ type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。 例如： 123456789101112int[][] a = new int[2][3];//含义是外层数组有两项，每项都有三个数据特殊的int[][] a = new int[2][];//这种写法也是正确的，代表的是里层数组的内容还不确定例如：String[][] s = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(&quot;Good&quot;);s[0][1] = new String(&quot;Luck&quot;);s[1][0] = new String(&quot;to&quot;);s[1][1] = new String(&quot;you&quot;);s[1][2] = new String(&quot;!&quot;); 注意：如下写法是错的 12int[][] a = new int[2][];a[0][0]=1;//error 空指针异常 因为不确定数组的长度 语法：(静态初始化) 1type[][]typeName=new Type[][]&#123;&#123;值1，值2&#125;,&#123;值1，值2&#125;,&#123;值1，值2&#125;&#125; 例如： 1234567int[][] arr=new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;或者如下写法也是正确的int[] arr[]=new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; //正确int [][] arr=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;//正确同样的如下写法也是错误的，原理同上int [][] arr;arr=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 7.6 Arrays 工具类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） 3 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 1.查找关键字 123int a[]=&#123;1,2,3,4,5,7,9&#125;;int index=Arrays.binarySearch(a,7);System.out.println(index);//5 返回7所在的角标5 2.比较数组是否相同 123456789import java.util.Arrays; //工具类，使用前先导包int a[]=&#123;1,2,3,4&#125;;int b[]=new int[]&#123;1,2,3,4&#125;;System.out.println(Arrays.equals(a,b));//true//以下会返回falseint a[]=&#123;1,2,3,4&#125;;int b[]=new int[]&#123;1,2,4,3&#125;;//顺序不同不行System.out.println(Arrays.equals(a,b));//false 3.数组排序 123456789int a[]=&#123;1,2,3,4&#125;;int b[]=new int[]&#123;1,2,4,3&#125;;Arrays.sort(b);System.out.println(b[3]);int a[]=&#123;1,2,3,4&#125;;int b[]=new int[]&#123;1,2,4,3&#125;;Arrays.sort(b);System.out.println(Arrays.toString(b));//[1, 2, 3, 4] 8.方法Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 8.1方法的定义语法： 1234567修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125;//如果没有返回值， 返回值类型填写void 例如 12345678910public static int max(int num1, int num2) &#123; int result; if (num1 &gt; num2) result = num1; else result = num2; return result;&#125;//调用方法int larger = max(30, 40); 注意，方法内不能再定义方法 8.2方法的重载方法重载概括成一句话就是同名不同参。 1.同名是指方法名相同 2.不同参是指参数个数不同 3.参数的类型不同(其中在参数类型不同时，参数的顺序不同也可以)， 方法重载只和方法名和方法参数有关，和方法的参数名字以及方法的返回值无关， 例如1:不同类型，参数顺序不同构成重载 12345678910public static void main(String[] args) &#123; add(&quot;hello&quot;,1);//调用第二个add 结果hello1 add(1,&quot;hello&quot;);//调用第一个add 结果1hello&#125;public static void add(int a,String b)&#123; System.out.println(a+b);&#125;public static void add(String b,int a)&#123; System.out.println(a+b);&#125; 例如2：参数个数不同构成重载 12345678910public static void main(String[] args) &#123; add(5,1); add(8); &#125; public static void add(int a)&#123; System.out.println(a); &#125; public static void add(int a, int b)&#123; System.out.println(a+b); &#125; 例如3：参数类型不同构成重载 123456public static void add(int a,int b)&#123; System.out.println(a+b); &#125; public static void add(int b,int a)&#123; System.out.println(a+b); &#125; 总结:方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。 8.3可变参数JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。 对于可变参数，编译器会将其转型为一个数组，故在函数内部，可变参数名即可看作数组名。 123456789import java.util.Arrays;public class Demo1 &#123; public static void main(String[] args) &#123; fn(&quot;hello&quot;,8,9,10); &#125; public static void fn(String a,int... arg)&#123; System.out.println(Arrays.toString(arg));//[8,9,10] 所以本质上可变参数就是个数组 &#125;&#125; 如果不用可变参数，用数组来写也是同理，如下 123456789import java.util.Arrays;public class Demo1 &#123; public static void main(String[] args) &#123; fn(new int[]&#123;8,9,10&#125;); &#125; public static void fn(int[] arg)&#123; System.out.println(Arrays.toString(arg));//[8,9,10] &#125;&#125; 8.4递归方法所谓的递归就是函数自己调用自己 求任意数值的阶乘： 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(fn(5)); &#125; public static int fn(int num)&#123; if(num==1)&#123; return 1; &#125;else&#123; return num*fn(num-1); &#125; &#125;&#125; 求任意区间数字之和: 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(fn(10)); &#125; public static int fn(int num)&#123; if(num==1)&#123; return 1; &#125;else&#123; return num+fn(num-1); &#125; &#125;&#125; 9.修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端 比如我们前面见到的public static 这都是修饰符 9.1 访问&#x2F;权限修饰符可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 修饰府 当前类 同一包内 不同包中的子类 不同包中的非子类 public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N 关于四种权限修饰符的测试 1.同一个类内部，四种权限修饰符都可以正常使用 2.同一个包内部，除了private，其他可以正常使用 3.非同一个包内的子类中，可以正常使用public和protected（如果子类跟父类在同一包下，那么除了private，其他也都是可以正常使用的） 4.非同一个包内非子类中，只有public可以使用 9.2 非访问修饰符static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。abstract 修饰符，用来创建抽象类和抽象方法。 具体内容见面向对象章节 10.面向对象10.1 类和对象Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类本质上是一个创建对象的模板，它描述一类对象的行为和状态 编写一个汽车类： 123456789public class Car &#123; //属性 String name; int price; String color; // 方法/行为 void run() &#123; &#125;&#125; 上面的案例中我们用到了一些属性或者叫变量，还有方法 案例 1234567891011121314151617public class Demo &#123; public static void main(String[] args)&#123; Car bmw=new Car(); bmw.color=&quot;red&quot;; bmw.run(); &#125;&#125;class Car &#123; //属性也叫成员变量 String name; int price=1000000; String color; // 方法/行为 void run() &#123; System.out.println(&quot;i can run&quot;); &#125;&#125; 或者我在Demo1.java文件中定义一个类，在Demo文件中调用也都是没问题的 例如： Demo1.java 123456789101112public class Demo1 &#123; public static void main(String[] args) &#123; &#125;&#125;class Person&#123; int age; String name; void sing()&#123; System.out.println(&quot;i can sing&quot;); &#125;&#125; Demo.java 123456public class Demo &#123; public static void main(String[] args)&#123; Person ll=new Person();//在这里可以直接调用不同文件的类。因为默认default修饰，同一包内可见 ll.sing(); &#125;&#125; 10.2 类中的变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 例如： 123456public class ClassName&#123; public void printNumber（）&#123; int a;//局部变量 &#125; // 其他代码&#125; 成员变量(非静态变量) 相当于前端js中的自有属性：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 例如： 123456public class ClassName&#123; int a;//成员变量 public void printNumber（）&#123; // 其他代码 &#125;&#125; 类变量(静态变量) 相当于前端js中的共有属性：类变量也声明在类中，方法体之外，但必须声明为static 类型。 例如： 123456public class ClassName&#123; static int a;//类变量 public void printNumber（）&#123; // 其他代码 &#125;&#125; 10.3 封装Java 封装，封装意味着将类的属性私有化，提供公共的方法来获取和设置属性 例如，我们下面的案例，我们定义的Person类，他的属性和方法可以随意在其他类比如Test01类改写，为什么可以被改写，因为默认修饰符default 同一包内都可以访问 123456789101112131415public class Test01 &#123; public static void main(String[] args) &#123; Person xm=new Person(); xm.name=&quot;小明&quot;; xm.age=18; xm.intr(); &#125;&#125;class Person&#123; String name; int age; void intr()&#123; System.out.println(&quot;我叫&quot;+name+&quot;我今年&quot;+age+&quot;岁&quot;); &#125;&#125; 那么如何来解决上面的问题呢？很容易想到private，因为private只能在同一类内访问 例如： 1234567891011121314151617181920212223242526272829303132public class Test01 &#123; public static void main(String[] args) &#123; Person xm=new Person(); xm.setAge(18); xm.setName(&quot;小明&quot;); System.out.println( xm.getName()); System.out.println( xm.getAge()); xm.intr(); &#125;&#125;class Person&#123; private String name; private int age; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int a) &#123; //age=age error age = a; //注意参数名不能跟属性名重名 &#125; public void setName(String b) &#123; name = b; &#125; public void intr()&#123; System.out.println(&quot;我叫&quot;+name+&quot;我今年&quot;+age+&quot;岁&quot;); &#125;&#125; 10.4 this关键字this可以用来修饰 上面的案例中我们说到了 参数名跟属性名不能重名 因为： 123public void setAge(int age) &#123; age = age; //如果这样写很难区分前后的age分别代表谁，程序会认为等号前后的age都代表参数age&#125; **解决:**this代表当前对象，注意是当前对象，不是当前类 在类的方法中，我们可以使用this.属性或者this.方法的方式，调用当前对象的属性或方法，但大多数情况下我们都省略了this。 单独使用this(),那么this代表构造器例如： 123456789101112131415161718public class HelloWorld &#123; public static void main(String[] args) &#123; Person a=new Person(&quot;xm&quot;); &#125;&#125;class Person&#123; Person()&#123; System.out.println(&quot;1&quot;); &#125; Person(String m)&#123; this();//代表调用自身的构造器 System.out.println(m); &#125;&#125;//1//xm 注意： 1.在构造器中不能自己调用自己，不然就是一个死循环了 2.另外，如果想直接调用构造器，调用构造器的代码必须写在第一行 3.调用构造器只能调用一次 10.5 构造方法&#x2F;构造器当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为protected，构造函数也改为 protected)。一旦你定义了自己的构造方法，默认构造方法就会失效。 事实上，我们以前new Person()创建一个对象，Person这个函数其实就是构造方法 对应的，构造函数还可以初始化对象的属性 如下： 123456789101112public class Test02 &#123; public static void main(String[] args) &#123; Persons xm=new Persons(18); System.out.println(xm.age); &#125;&#125;class Persons&#123; int age; public Persons(int a)&#123; age=a; &#125;&#125; 特殊的，构造器也可以有多个,本质上其实就是方法的重载 1234567891011121314151617public class Test02 &#123; public static void main(String[] args) &#123; Persons xm=new Persons(18); Persons ll=new Persons(&quot;李雷&quot;); System.out.println(ll.name); &#125;&#125;class Persons&#123; int age; String name; public Persons(int a)&#123; age=a; &#125; public Persons(String a)&#123; name=a; &#125;&#125; 10.6 package1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包下，不能有重名的类。不同包下，可以有同名的类 包名其实就是路径名例如： 1234package net.java.util;public class Something&#123; ...&#125; 那么它的路径应该是 net&#x2F;java&#x2F;util&#x2F;Something.java 这样保存的。 package(包) 的作用是把不同的 java程序分类保存，更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 包名的命名规范 1.包名全部用小写字母 10.6.1 import为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 注意： import 声明必须在包声明之后，类声明之前。 1.如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。也不需要引入所以我们之前很多的包名都没有写 2.如果需要引入某一个包下的所有结构，可以使用 1import index.*; 3.如果引入的多个包，包名相同的情况 例如目前 index包下有一个Test.java index2包下有一个Test.java 现在需要在other包下引入两个Test.java，，目前重名肯定不能直接引入 解决方案：全类名 10.7 继承10.7.1 什么叫继承：继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般语法如下： 1234class 父类 &#123;&#125;class 子类 extends 父类 &#123;&#125; 10.7.2为什么要使用继承从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 例如：车是一个类别，但是现实中有很多车，像车的颜色型号排量价格是每个车都具有的属性，他们本质上都属于车。所以这个时候我们就可以通过继承快速创建子类实例对象 但是注意，如果父类的属性为private，子类同样是无法访问的 10.7.3继承的特点1.Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class SubDemo extends Demo&#123;&#125; //okclass SubDemo extends Demo1,Demo2...//error 2.Java支持多层（重）继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 3.子类拥有父类非 private 的属性、方法。 4.子类可以拥有自己的属性和方法，也可以对父类进行扩展。 特殊的情况：如果子类自定义的方法和父类的重名，会优先访问子类自己的。这种方式称之为方法的重写 关于构造器： 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 10.8重写(Override)和重载(Overload)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。 重写的注意事项 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类&#x2F;子类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法。 重写和重载的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 10.9 super关键字super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。如果直接父类找不到，会一直向上找 super可以修饰：属性、方法、构造器 10.9.1super的两种用法1.普通的直接引用 与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。2.引用构造函数 super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。另外子类构造器默认都会调用super()方法，无论你写没写 10.9.2 super 和 this的异同 super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。 super() 和 this() 均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static方法，static 语句块。 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。 10.10 多态10.10.1 什么是多态 多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现 总的来说：同一件事，发生在不同对象身上，就会产生不同的结果 比如：以前我们声明什么类就需要new 什么类，现在我声明Animal类创建Cat类，也是没错的。相当于用一个更大的范围去修饰一个更具体的对象 10.10.2多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p &#x3D; new Child(); 10.10.3 多态有什么用下面是个案例，解释了多态的实际作用例如： 1234567891011121314151617181920212223242526272829303132package other;public class Demo &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat &#125; public static void show(Animal a) &#123; a.eat(); &#125;&#125;class Animal &#123; void eat()&#123; &#125;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void work() &#123; System.out.println(&quot;看家&quot;); &#125;&#125; 上面的案例中 如果没有多态：我们需要自己给子类创建方法，才能调用有多态：我们可以直接使用父类定义的方法，子类无需定义就可以使用 注意：如上代码中，我如果在下图位置加上a.work是否正确 答案是错误的，不允许的 因为work是Cat才有的，Animal没有。可能很多人认为多态我们默认调用的不也是子类自己的方法吗，为什么这里不行？ 注意！！！！！！当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。属性是不具备多态性的，访问属性都是去访问子类自己的属性 如果必须就是想让a使用work方法，也可以，答案就是使用强制类型转换，如下图 10.10.4 虚方法子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法 称位虚拟方法，父类根据赋给他的不同的子类对象，动态调用属于子类的该方法，这样的方法调用在编译期是无法确定的。 10.11 包装类10.11.1 基本概念包装类产生原因：因为基本数据类型无法进行对象化处理，所以就引入了包装类 包装类：拥有属性、方法，可以对象化交互 包装类与基本数据类型对应 1.Java中数值型包装类都是继承自number类型，都是用final修饰的，不可以继承2.Boolean和character都是继承自Object类 10.11.2 基本数据类型转为包装类基本数据类型转为对应的包装类对象称为装箱。 10.11.3 包装类转为基本数据类型包装类对象转为对应的基本类型称为拆箱。 10.11.4 自动装箱和自动拆箱123456789101112public class WrapperTest &#123; public void test3()&#123; //自动装箱：基本数据类型-&gt;包装类 int num1 = 10; Integer num2 = num1; boolean b1 = true; boolean b2 = b1; //自动拆箱：包装类-&gt;基本数据类型 int num3 = num2; &#125;&#125; 10.11.5 基本数据类型、包装类和String类型之间的转换1234567891011121314151617public class WrapperTest &#123; // 基本数据类型、包装类-&gt;String类型 @Test public void test4() &#123; int num1 = 10; //方式1：连接运算 String str1 = num1 + &quot;&quot;; //方式2：调用String重载的valueOf方法 float f1 = 12.34f; String str2 = String.valueOf(f1); System.out.println(str2); Double d1 = new Double(12.3); String str3 = String.valueOf(d1); System.out.println(str3); &#125;&#125; 10.11.6 String类型转为基本数据类型、包装类123456789101112public class WrapperTest &#123; // String类型-&gt;基本数据类型 @Test public void test5() &#123; String str1 = &quot;123&quot;; int num2 = Integer.parseInt(str1); System.out.println(num2); String str2 = &quot;true&quot;; boolean b1 = Boolean.parseBoolean(str2); System.out.println(b1); &#125;&#125; 10.12 static关键字 “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” （相类似于js中的共有属性），但是每个实例对象都可以直接修改静态变量 静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 因为静态变量是在对象创建之前就有的所以：1.静态方法中，只能调用静态属性或方法2.对于非静态方法，既可以调用非静态方法和属性也可以调用静态方法和属性所以在使用static的时候，内部不能使用this关键字，super同理也不能使用，因为还没创建对象。 10.13 代码块1.静态代码块 可以有输出语句可以对类的属性声明进行初始化操作不可以对非静态的属性进行初始化。 即不可以调用非静态的属性和方法。若有多个静态的代码块，则按照从上到下的顺序依次执行。静态代码块的执行要先于非静态代码块。静态代码只执行一次。 12345678910111213141516public class Per &#123; static &#123; System.out.println(&quot;静态代码块1&quot;); &#125; static&#123; System.out.println(&quot;静态代码块2&quot;); &#125; &#123; System.out.println(&quot;非静态代码块&quot;); &#125; Per() &#123; System.out.println(&quot;per的构造函数&quot;); &#125;&#125; 2.非静态代码块 可以有输出语句可以对类的属性声明进行初始化操作可以调用静态或者非静态的变量或方法若有多个非静态的代码块，那么按照从上到下的顺序依次执行再次创建对象的时候都会执行，且先于构造函数执行 123456789101112131415public class Per &#123; &#123; System.out.println(&quot;非静态代码块1&quot;); &#125; &#123; System.out.println(&quot;非静态代码块2&quot;); &#125; &#123; System.out.println(&quot;非静态代码块3&quot;); &#125; Per() &#123; System.out.println(&quot;per的构造函数&quot;); &#125;&#125; 10.14 final关键字final 变量：final 表示”最后的、最终的”含义。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。 1.final可以修饰变量 变量一旦赋值后，不能被重新赋值 12345678910public class Test&#123; final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue()&#123; value = 12; //将输出一个错误 &#125;&#125; 2.final修饰类 final 类不能被继承，没有类能够继承 final 类的任何特性。 123public final class Test &#123; // 类体&#125; 3.final修饰方法 父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改 12345public class Test&#123; public final void changeName()&#123; // 方法体 &#125;&#125; 4.final修饰的成员变量初始化方式 定义变量时直接赋值在构造器中赋值也可以，但在每个构造器中都需要有赋值语句代码块中也可以完成初始化 5.final修饰的类变量初始化方式 定义变量时直接赋值静态代码块中也可以完成初始化 10.15 抽象类 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。 我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类 1.抽象方法 语法： 123修饰符 abstract 返回值类型 方法名 (参数列表)；如：public abstract void run()； 2.抽象类 语法： 123abstract class 类名字 &#123;&#125;如public abstract class Animal &#123;public abstract void run()；&#125; 抽象类五大要点 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 2.抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。因为只要存在抽象方法，就不能有对象调用，所以如果不是抽象类，就可以创建对象并调用，这是不对的 3.抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 4.构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 5.抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 如果没有实现就会报错： 关于抽象类的案例：求各个图形面积 10.16 接口接口（英文：Interface） ：本质上是抽象方法的集合 ，一个类通过继承接口的方式，从而来继承接口的抽象方法。 1、接口的本质 普通类：只有具体实现抽象类：具体实现和规范(抽象方法) 都有！接口：只有规范！ 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口声明的语法 123456789[可见度] interface 接口名称 [extends 其他的接口名] &#123; // 声明变量 // 抽象方法&#125;例如interface Animal &#123; public void eat(); public void travel();&#125; 接口实现的语法 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 例如 123456789101112131415161718192021interface Animal &#123; public void eat(); public void travel();&#125;public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 接口的特性 **1.**接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 publicabstract，其他修饰符都会报错）。 123456interface Action&#123; public abstract void run(); //默认就是public abstract修饰的 void test(); public void go();&#125; **2.**接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是public，用 private 修饰会报编译错误）。 注:可以直接使用接口名访问其属性。因为是public static修饰的注:声明的同时就必须赋值.(因为接口中不能编写静态代码块) **3.**接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。**4.**一个类可以实现多个接口**5.**如果继承和实现接口同时存在，先继承，再实现**6.**接口与接口之间可以继承，并且可以是多继承 接口的多继承 1public interface Hockey extends Sports, Event 10.17 内部类概念： 在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 10.17.1 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部 1234567891011121314class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //成员内部类 public void drawSahpe() &#123; System.out.println(&quot;drawshape&quot;); &#125; &#125;&#125;//实例化Draw 实例化内部类: 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 并且内部类可以被四种权限修饰符修饰，不同于之前只有default 和public修饰 内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Draw 用 private 修饰，则只能在外部类的内部访问，如果用 public修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 10.17.2 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; //静态内部类 static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 10.17.3 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内 123456789101112131415161718class People&#123; public People() &#123; &#125;&#125;class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static修饰符的。 10.17.4 匿名内部类就是内部类的简化写法 **前提:**存在一个类或者接口(这里的类可以是具体类也可以是抽象类) 格式: 123new 类名或者接口名() &#123; 重写方法; &#125;; **本质是:**一个继承了该类或者是实现了该接口的子类匿名对象 10.18 枚举 Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类 首先我们不用枚举类型，也可以，我们可以采用如下写法 12345678910111213141516171819public class ThreadPool &#123; public static void main(String[] args) &#123; //未采用枚举类型的写法 System.out.println(Test.boy); System.out.println(Test.girl); //采用枚举类型的写法 System.out.println(Gender.BOY); System.out.println(Gender.GIRL); &#125;&#125;//未采用枚举类型的写法class Test &#123; public static final int boy = 1; public static final int girl = 2;&#125;//采用枚举类型的写法enum Gender&#123; BOY,GIRL&#125; Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割 12345678910111213enum Color&#123; RED, GREEN, BLUE;&#125;public class Test&#123; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); &#125;&#125; 声明在类内部也是可以的 1234567891011package index2;public class Test &#123; enum Color &#123; RED, GREEN, BLUE; &#125; public static void main(String[] args) &#123; Color c=Color.BLUE; System.out.println(c); &#125;&#125; values(), ordinal() 和 valueOf() 方法 enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和java.lang.Comparable 两个接口。 values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中： values() 返回枚举类中所有的值。 ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。 valueOf()方法返回指定字符串值的枚举常量。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-04-22T15:35:15.834Z","updated":"2023-04-22T15:35:15.834Z","comments":true,"path":"2023/04/22/hello-world/","link":"","permalink":"http://example.com/2023/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}