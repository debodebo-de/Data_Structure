<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础到面向对象</title>
    <link href="/2023/04/23/java%E5%9F%BA%E7%A1%80%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/04/23/java%E5%9F%BA%E7%A1%80%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="IDEA-debug-基础调试技能"><a href="#IDEA-debug-基础调试技能" class="headerlink" title="IDEA debug 基础调试技能"></a>IDEA debug 基础调试技能</h2><ul><li><p>断点<br>在需要停留的代码位置打个标示，程序运行到这个地方会暂停<br><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220630104647999.png" alt="image-20220630104647999"></p></li><li><p>开启调试模式<br><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220630104912899.png" alt="image-20220630104912899"></p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220630105124084.png" alt="image-20220630105124084"></p><ul><li>step over：程序向下执行一行</li><li>step into ：进入自定义方法</li><li>step out ：跳出对应的方法</li></ul></li></ul><h2 id="JAVA注释使用"><a href="#JAVA注释使用" class="headerlink" title="JAVA注释使用"></a>JAVA注释使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个是单行注释</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *这个是多行注释</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *这个是文档注释，描述类的作用</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@author</span> 噢噢</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@version</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="JAVA模块和划分包的使用"><a href="#JAVA模块和划分包的使用" class="headerlink" title="JAVA模块和划分包的使用"></a>JAVA模块和划分包的使用</h2><ul><li><p>格式规范<br><strong>包名：</strong>全部小写字母，可以是域名反过来写</p></li><li><p>怎样导入其他包</p><ul><li><p><strong>import</strong>关键词导入其他包下的类<br>eg：导入工具类包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导入util包下的Date类</span><br><span class="hljs-keyword">import</span> java.util.Date;<br>    <br><span class="hljs-comment">//*号表示这个util包下面的类全都导入进来</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="JAVA核心基础知识之修饰符"><a href="#JAVA核心基础知识之修饰符" class="headerlink" title="JAVA核心基础知识之修饰符"></a>JAVA核心基础知识之修饰符</h2><ul><li>访问修饰符：<ul><li>限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符</li><li>private &lt; default &lt;protected &lt; public</li></ul></li><li>非访问修饰符：用来修饰或者辅助功能</li><li>主要记住：<ul><li>外部类修饰符：public或者默认</li><li>方法、属性类修饰符：private、default、protected、public<ul><li>public - 公开对外部可见</li><li>protected - 对所有包和所有子类可见</li><li>private- 仅对内部可见</li></ul></li></ul></li><li>方法（属性）级别</li></ul><table><thead><tr><th>修饰府</th><th>当前类</th><th>同一包内</th><th>不同包中的子类</th><th>不同包中的非子类</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><ul><li>属性或者成员变量，都用必须用private修饰</li></ul><h2 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1.变量与数据类型"></a>1.变量与数据类型</h2><h3 id="1-1什么是变量"><a href="#1-1什么是变量" class="headerlink" title="1.1什么是变量"></a>1.1什么是变量</h3><p>1.变量是内存中的一块存储区域<br>2.变量是用来存数据的</p><h3 id="1-2使用变量"><a href="#1-2使用变量" class="headerlink" title="1.2使用变量"></a>1.2使用变量</h3><p>java是一个强类型的语言：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">强类型语言也称为强类型定义语言。是一种总是强制类型定义的语言，<br>要求变量的使用要严格符合定义，所有变量都必须先定义后使用<br></code></pre></td></tr></table></figure><p>1.java中的变量必须先声明，后使用</p><p>java中声明变量的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//变量类型 变量名=数据 如</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">18</span><br><span class="hljs-comment">//也可以先声明，再赋值</span><br><span class="hljs-type">int</span> num<br>num=<span class="hljs-number">18</span><br><span class="hljs-comment">//也可以同时声明多个</span><br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, e = <span class="hljs-number">4</span>, f = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//注意只声明不赋值，使用的时候会报错，因为变量没有默认值</span><br><span class="hljs-comment">//变量不允许重复声明</span><br></code></pre></td></tr></table></figure><h3 id="1-3变量的分类"><a href="#1-3变量的分类" class="headerlink" title="1.3变量的分类"></a>1.3变量的分类</h3><p>Java 中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（实例变量）</li></ul><p><strong>成员变量、局部变量、静态变量的区别</strong></p><table><thead><tr><th></th><th>成员变量</th><th>局部变量</th><th>静态变量</th></tr></thead><tbody><tr><td>定义位置</td><td>在类中,方法外</td><td>方法中,或者方法的形式参数</td><td>在类中,方法外</td></tr><tr><td>初始化值</td><td>有默认初始化值</td><td>无,先定义,赋值后才能使用</td><td>有默认初始化值</td></tr><tr><td>调用方式</td><td>对象调用</td><td>—</td><td>对象调用，类名调用</td></tr><tr><td>存储位置</td><td>堆中</td><td>栈中</td><td>方法区</td></tr><tr><td>生命周期</td><td>与对象共存亡</td><td>与方法共存亡</td><td>与类共存亡</td></tr><tr><td>别名</td><td>实例变量</td><td>—</td><td>类变量</td></tr></tbody></table><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="2-1数据类型汇总"><a href="#2-1数据类型汇总" class="headerlink" title="2.1数据类型汇总"></a>2.1数据类型汇总</h3><p>按照数据类型来分</p><p>​<strong>基本数据类型：</strong>一共有八个，六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p>​（1）数字类型<br>​整数类型：byte， short， int，long<br>​浮点类型：float，double<br>​（2）字符类型：char<br>​（3）布尔类型：boolean</p><p>​<strong>引用数据类型：</strong>类（class） 接口(interface) 数组([])</p><h3 id="2-2整数类型"><a href="#2-2整数类型" class="headerlink" title="2.2整数类型"></a>2.2整数类型</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span> GB = <span class="hljs-number">1024</span> MB，GB：千兆<br><span class="hljs-number">1</span> MB = <span class="hljs-number">1024</span> KB，MB：兆<br><span class="hljs-number">1</span> KB = <span class="hljs-number">1024</span> <span class="hljs-keyword">B，KB：千字节，B </span>是 <span class="hljs-keyword">Byte </span>的缩写，即字节<br><span class="hljs-number">1</span> <span class="hljs-keyword">Byte </span>= <span class="hljs-number">8</span> <span class="hljs-keyword">Bit。</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Bit——Binary </span><span class="hljs-keyword">Digit（二进制数位）的缩写，叫作“位”或“比特”，是计算机运算的基础。Bit </span>代表二进制<br>数位，取值范围为：<span class="hljs-number">0</span> 或 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位(1个字节大小)、有符号的，以二进制补码表示的整数；</li><li>最小值是 -128（-2^7）；</li><li>最大值是 127（2^7-1）；</li><li>默认值是 0；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四<br>分之一；</li><li>例子：byte a &#x3D; 100，byte b &#x3D; -50。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> a=<span class="hljs-number">128</span>;<span class="hljs-comment">//error 因为byte最大值是127</span><br></code></pre></td></tr></table></figure><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位（2个字节大小）、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>例子：short s &#x3D; 1000，short r &#x3D; -20000。</li></ul><p><strong>int：</strong>最最常用的整数类型</p><ul><li>int 数据类型是32位（4个字节大小）、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 0 ；</li><li>例子：int a &#x3D; 100000, int b &#x3D; -200000。</li></ul><p><strong>long：</strong> long型变量必须以大写L结尾</p><ul><li>long 数据类型是 64 位（8个字节大小）、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 0L；</li><li>例子： long a &#x3D; 100000L，long b &#x3D; -200000L。</li></ul><h3 id="2-3-浮点型"><a href="#2-3-浮点型" class="headerlink" title="2.3 浮点型"></a>2.3 浮点型</h3><p><strong>float：</strong>float型变量必须以大写F或者小写f结尾</p><ul><li>float 数据类型是单精度、32位（4个字节大小）、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>范围：-3.40E+38 ~ +3.40E+38 E表示10的多少次方的意思（float 类型可最大表示3.4x10^38）</li><li>默认值是 0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 &#x3D; 234.5f。</li></ul><p><strong>double</strong>：</p><ul><li>double 数据类型是双精度、64 位（8个字节大小）、符合 IEEE 754 标准的浮点数；</li><li>浮点数的默认类型为 double 类型；</li><li>范围：-1.79E+308 ~ +1.79E+308 精度正好是float的两倍，所以叫双精度</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 0.0d；</li><li>例子： double a&#x3D;2.5</li></ul><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>char：</strong>注意要写在单引号里,不是双引号</p><ul><li>char 类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 \u0000（十进制等效值为 0）；</li><li>最大值是 \uffff（即为 65535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter &#x3D; ‘A’;。</li><li>取值范围<br>大写字母（A-Z）：65 （A）~ 90（Z）<br>小写字母（a-z）：97（a） ~ 122（z）<br>字符数字（’0’ ~ ‘9’）：48（’0’） ~ 57（’9’）</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span>类型是可以运算的因为<span class="hljs-type">char</span>在ASCII等字符编码表中有对应的数值。<br>在JAVA中，对<span class="hljs-type">char</span>类型字符运行时，直接当做ASCII表对应的整数来对待。<br></code></pre></td></tr></table></figure><h3 id="2-5布尔型"><a href="#2-5布尔型" class="headerlink" title="2.5布尔型"></a>2.5布尔型</h3><p>布尔只有两个值 true或者false</p><h2 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h2><h3 id="3-1自动类型转换"><a href="#3-1自动类型转换" class="headerlink" title="3.1自动类型转换"></a>3.1自动类型转换</h3><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进<br>行运算。<br>转换从低级到高级。也就是说小的数据可以转成大的，因为大的取值范围一定包含小的值的取值范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">低 ------------------------------------&gt; 高<br><span class="hljs-type">byte</span>,<span class="hljs-type">short</span>,<span class="hljs-type">char</span>—&gt; <span class="hljs-type">int</span> —&gt; <span class="hljs-type">long</span>—&gt; <span class="hljs-type">float</span> —&gt; <span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><p>自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型<br>例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型</p><p>同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><h3 id="3-2强制类型转换"><a href="#3-2强制类型转换" class="headerlink" title="3.2强制类型转换"></a>3.2强制类型转换</h3><p>将容量大的转成容量小的，例如将double转成int</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> a=<span class="hljs-number">12.5</span>;<br><span class="hljs-type">int</span> b=a;<span class="hljs-comment">//error 不兼容的类型: 从double转换到int可能会有损失</span><br></code></pre></td></tr></table></figure><p>这样直接赋值会报错，所以需要强制转换</p><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(type)value<br></code></pre></td></tr></table></figure><p>重新运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> a=<span class="hljs-number">12.5</span>;<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)a;<br>System.out.println(b);<span class="hljs-comment">//12 注意，只取整数部分，哪怕是12.9也是12</span><br><span class="hljs-comment">//这种情况可能会损失精度</span><br></code></pre></td></tr></table></figure><p>但是也不是说所有情况都会损失精度，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)i1;<span class="hljs-comment">//强制类型转换为byte 123</span><br></code></pre></td></tr></table></figure><p>还有一种特殊情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">128</span>;<br><span class="hljs-type">byte</span> b=(<span class="hljs-type">byte</span>)a;<br>System.out.println(b);<span class="hljs-comment">//-128</span><br></code></pre></td></tr></table></figure><p>为什么结果式-128呢？，因为byte中127后一位就是-128，理解为时钟的效果就可以</p><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><h3 id="4-1算术运算符"><a href="#4-1算术运算符" class="headerlink" title="4.1算术运算符"></a>4.1算术运算符</h3><p>一般：+     -     *     &#x2F;     %</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21（区别详见下文）</td></tr><tr><td>–</td><td>自减: 操作数的值减少1</td><td>B– 或 –B 等于 19（区别详见下文）</td></tr></tbody></table><p><strong>特殊的，关于++和–，放在前后不一样</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>、前缀自增自减法(++<span class="hljs-keyword">a</span>,<span class="hljs-comment">--a): 先进行自增或者自减运算，再进行表达式运算。</span><br><span class="hljs-number">2</span>、后缀自增自减法(<span class="hljs-keyword">a</span>++,<span class="hljs-keyword">a</span><span class="hljs-comment">--): 先进行表达式运算，再进行自增或者自减运算</span><br></code></pre></td></tr></table></figure><h3 id="4-2赋值运算符"><a href="#4-2赋值运算符" class="headerlink" title="4.2赋值运算符"></a>4.2赋值运算符</h3><p>例如：&#x3D;     +&#x3D;     -&#x3D;       *&#x3D;      &#x2F;&#x3D;      （%）&#x3D;</p><p><strong>注意</strong>：<br>        C + &#x3D; A 与 C &#x3D; C + A 是有区别的一句话总结： +&#x3D; 运算符既可以实现运算，又不会更改 s 的数据<br>类型；而后者，C 和 A 必须是同一类型，否则无法直接运算。</p><h3 id="4-3关系运算符"><a href="#4-3关系运算符" class="headerlink" title="4.3关系运算符"></a>4.3关系运算符</h3><p>例如：&#x3D;&#x3D;    !&#x3D;    &gt;    &lt;    &gt;&#x3D;     &lt;&#x3D;</p><p><strong>注意：</strong>比较字符串<br>        字符串.equals(字符串)</p><h3 id="4-4逻辑运算符"><a href="#4-4逻辑运算符" class="headerlink" title="4.4逻辑运算符"></a>4.4逻辑运算符</h3><p>例如：&amp;&amp;（与）    ||（或）    !（非）</p><p><strong>注意：</strong><br>        &amp;&amp; 和 || 进行运算时有短路性</p><h3 id="4-5三元运算符"><a href="#4-5三元运算符" class="headerlink" title="4.5三元运算符"></a>4.5三元运算符</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">variable</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (expression) ? value <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> : value <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> c=a&gt;b?a:b;<br>System.out.println(c);<span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure><h3 id="4-6运算符优先级"><a href="#4-6运算符优先级" class="headerlink" title="4.6运算符优先级"></a>4.6运算符优先级</h3><p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>expr++ expr–</td><td>从左到右</td></tr><tr><td>一元</td><td>++expr –expr + - ～ ！</td><td>从右到左</td></tr><tr><td>乘性</td><td>* &#x2F;％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td><td>左到右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D; !&#x3D;</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>|</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>||</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; |&#x3D;</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table><h3 id="4-7-instaceof"><a href="#4-7-instaceof" class="headerlink" title="4.7 instaceof"></a>4.7 instaceof</h3><p>a instance of b</p><p>判断a对象是否是b对象的实例</p><h2 id="5-scanner类"><a href="#5-scanner类" class="headerlink" title="5.scanner类"></a>5.scanner类</h2><p>scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p><p>我们要使用他就必须导入，这个包是由系统提供的，我们装jdk的时候就已经装好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//2.创建一个scanner对象</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-comment">//从键盘接收数据</span><br><span class="hljs-comment">//3.nextInt方法接收一个数字</span><br><span class="hljs-type">int</span> a=scan.nextInt();<br>System.out.println(a);<br>&#125;<br>&#125;<br><span class="hljs-comment">//此时就可以终端输入了</span><br></code></pre></td></tr></table></figure><p>上面我们通过nextInt接受一个数字，如果需要接受字符串，布尔等也是可以的</p><p>小demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">// 从键盘接收数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>;<br>System.out.print(<span class="hljs-string">&quot;输入整数：&quot;</span>);<br><span class="hljs-keyword">if</span> (scan.hasNextInt()) &#123;<br><span class="hljs-comment">// 判断输入的是否是整数</span><br><span class="hljs-comment">//获取字符串是next()方法</span><br>i = scan.nextInt();<br><span class="hljs-comment">// 接收整数</span><br>System.out.println(<span class="hljs-string">&quot;整数数据：&quot;</span> + i);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 输入错误的信息</span><br>System.out.println(<span class="hljs-string">&quot;输入的不是整数！&quot;</span>);<br>&#125;<br>System.out.print(<span class="hljs-string">&quot;输入小数：&quot;</span>);<br><span class="hljs-keyword">if</span> (scan.hasNextFloat()) &#123;<br><span class="hljs-comment">// 判断输入的是否是小数</span><br>f = scan.nextFloat();<br><span class="hljs-comment">// 接收小数</span><br>System.out.println(<span class="hljs-string">&quot;小数数据：&quot;</span> + f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 输入错误的信息</span><br>System.out.println(<span class="hljs-string">&quot;输入的不是小数！&quot;</span>);<br>&#125;<br>scan.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6.流程控制"></a>6.流程控制</h2><h3 id="6-1if-else"><a href="#6-1if-else" class="headerlink" title="6.1if else"></a>6.1if else</h3><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(布尔值)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(布尔值)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-switch-case"><a href="#6-2-switch-case" class="headerlink" title="6.2 switch case"></a>6.2 switch case</h3><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br><span class="hljs-keyword">case</span> value :<br><span class="hljs-comment">//语句</span><br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">case</span> value :<br><span class="hljs-comment">//语句</span><br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br><span class="hljs-comment">//你可以有任意数量的case语句</span><br><span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br><span class="hljs-comment">//语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符<br>串 String 类型了，同时 case 标签必须为字符串常量或字面量。也就是说switch()里放布尔值都是不可<br>以的</p><p><strong>注意：如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值</strong><br><strong>都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。(也就是说匹配成功之后，后面就不</strong><br><strong>判断条件，后面的全都执行)</strong></p><h3 id="6-3-循环结构"><a href="#6-3-循环结构" class="headerlink" title="6.3 循环结构"></a>6.3 循环结构</h3><p>定义：程序反复运行一套代码，这就叫循环</p><p>Java中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><h4 id="6-3-1-while循环"><a href="#6-3-1-while循环" class="headerlink" title="6.3.1 while循环"></a>6.3.1 while循环</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>( 布尔表达式 ) &#123;<br><span class="hljs-comment">//循环内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(a&lt;<span class="hljs-number">10</span>)&#123;<br>a++;<br>System.out.println(<span class="hljs-string">&quot;执行了一次&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-3-2-do-while循环"><a href="#6-3-2-do-while循环" class="headerlink" title="6.3.2 do while循环"></a>6.3.2 do while循环</h4><p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//代码语句</span><br>&#125;<span class="hljs-keyword">while</span>(布尔表达式);<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">11</span>;<br><span class="hljs-keyword">do</span>&#123;<br>a++;<br>System.out.println(<span class="hljs-string">&quot;哈哈&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span>(a&gt;<span class="hljs-number">15</span>);<br><span class="hljs-comment">//哪怕条件不成立，也是会执行</span><br></code></pre></td></tr></table></figure><h4 id="6-3-3-for循环"><a href="#6-3-3-for循环" class="headerlink" title="6.3.3 for循环"></a>6.3.3 for循环</h4><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化; 布尔表达式; 更新) &#123;<br><span class="hljs-comment">//代码语句</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-3-4-break和continue"><a href="#6-3-4-break和continue" class="headerlink" title="6.3.4 break和continue"></a>6.3.4 break和continue</h4><p><strong>break</strong> 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。<br>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p><p><strong>continue</strong> 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。<br>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p><h2 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h2><h3 id="7-1-什么是数组："><a href="#7-1-什么是数组：" class="headerlink" title="7.1 什么是数组："></a>7.1 什么是数组：</h3><p>数组是用来存储固定大小的同类型元素<br>数组存放是不限制数据类型的可以是int 可以是 double甚至可以是自定义类</p><h3 id="7-2-声明数组"><a href="#7-2-声明数组" class="headerlink" title="7.2 声明数组"></a>7.2 声明数组</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">dataType[] arrayRefVar; <span class="hljs-comment">// 首选的方法</span><br>例如：<br><span class="hljs-type">double</span>[] myList = &#123;<span class="hljs-number">1.9</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">3.5</span>&#125;;<br>或<br>dataType arrayRefVar[]; <span class="hljs-comment">// 效果相同，但不是首选方法</span><br>例如：<br><span class="hljs-type">double</span> myList[] = &#123;<span class="hljs-number">1.9</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">3.5</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-3数组初始化"><a href="#7-3数组初始化" class="headerlink" title="7.3数组初始化"></a>7.3数组初始化</h3><p>1.静态初始化</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">dataType[] <span class="hljs-built_in">array</span>RefVar = &#123;value0, value1, ..., valuek&#125;;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numList=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>或者<br><span class="hljs-type">int</span>[] numList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>但是注意，如下写法不行,因为在一行写默认有类型推断不会报错，换行写无法推断<br><span class="hljs-type">int</span> numList<br>numList=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><p>2.动态初始化</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">dataType[] arrayRefVar <span class="hljs-operator">=</span> new dataType[arraySize]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure><h3 id="7-4数组的访问"><a href="#7-4数组的访问" class="headerlink" title="7.4数组的访问"></a>7.4数组的访问</h3><p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 array.length-1。</p><p>更改数组直接通过：</p><p>数组名[索引]&#x3D;”值”</p><p><strong>注意：</strong>下面这种会出现数组角标越界的错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>numList[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>numList[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br>numList[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;<span class="hljs-comment">//error ArrayIndexOutOfBoundsException 因为内容超出了数组的长度范围</span><br></code></pre></td></tr></table></figure><p>特殊的，JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标<br>的情况下遍历数组</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(type element: array)<br>&#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestArray</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">double</span>[] myList = &#123;<span class="hljs-number">1.9</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">3.5</span>&#125;;<br><br>        <span class="hljs-comment">// 打印所有数组元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> element: myList) &#123;<br>System.out.println(element);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-二维数组"><a href="#7-5-二维数组" class="headerlink" title="7.5 二维数组"></a>7.5 二维数组</h3><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维<br>数组</p><p>语法：</p><p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，<br>typeLength1 为行数，typeLength2 为列数。</p><p>语法：(动态初始化)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[][] typeName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">type</span>[typeLength1][typeLength2];<br></code></pre></td></tr></table></figure><p>​type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，<br>typeLength1 为行数，typeLength2 为列数。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<span class="hljs-comment">//含义是外层数组有两项，每项都有三个数据</span><br>特殊的<br><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][];<span class="hljs-comment">//这种写法也是正确的，代表的是里层数组的内容还不确定</span><br>例如：<br>String[][] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span>][];<br>s[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span>];<br>s[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Good&quot;</span>);<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Luck&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;to&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;you&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：如下写法是错的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][];<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//error 空指针异常 因为不确定数组的长度</span><br></code></pre></td></tr></table></figure><p>语法：(静态初始化)</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">type[][]typeName=new Type[][]</span><span class="hljs-template-variable">&#123;&#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>&#125;,&#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>&#125;,&#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br>或者如下写法也是正确的<br><span class="hljs-type">int</span>[] arr[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> [][] arr=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<span class="hljs-comment">//正确</span><br>同样的如下写法也是错误的，原理同上<br><span class="hljs-type">int</span> [][] arr;<br>arr=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-6-Arrays-工具类"><a href="#7-6-Arrays-工具类" class="headerlink" title="7.6 Arrays 工具类"></a>7.6 Arrays 工具类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的</p><p>具有以下功能：</p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><table><thead><tr><th>序号</th><th>方法和说明</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</td></tr><tr><td>2</td><td><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）</td></tr><tr><td>3</td><td><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr></tbody></table><p>1.查找关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> index=Arrays.binarySearch(a,<span class="hljs-number">7</span>);<br>System.out.println(index);<span class="hljs-comment">//5 返回7所在的角标5</span><br></code></pre></td></tr></table></figure><p>2.比较数组是否相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays; <span class="hljs-comment">//工具类，使用前先导包</span><br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> b[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>System.out.println(Arrays.equals(a,b));<span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//以下会返回false</span><br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> b[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//顺序不同不行</span><br>System.out.println(Arrays.equals(a,b));<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>3.数组排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> b[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<br>Arrays.sort(b);<br>System.out.println(b[<span class="hljs-number">3</span>]);<br><br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> b[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<br>Arrays.sort(b);<br>System.out.println(Arrays.toString(b));<span class="hljs-comment">//[1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><h3 id="8-1方法的定义"><a href="#8-1方法的定义" class="headerlink" title="8.1方法的定义"></a>8.1方法的定义</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>...<br>方法体<br>...<br><span class="hljs-keyword">return</span> 返回值;<br>&#125;<br><span class="hljs-comment">//如果没有返回值， 返回值类型填写void</span><br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br><span class="hljs-type">int</span> result;<br><span class="hljs-keyword">if</span> (num1 &gt; num2)<br>result = num1;<br><span class="hljs-keyword">else</span><br>result = num2;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">//调用方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">larger</span> <span class="hljs-operator">=</span> max(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><p>注意，方法内不能再定义方法</p><h3 id="8-2方法的重载"><a href="#8-2方法的重载" class="headerlink" title="8.2方法的重载"></a>8.2方法的重载</h3><p>方法重载概括成一句话就是同名不同参。<br>        1.同名是指方法名相同<br>        2.不同参是指参数个数不同<br>        3.参数的类型不同(其中在参数类型不同时，参数的顺序不同也可以)，</p><p>方法重载只和方法名和方法参数有关，和方法的参数名字以及方法的返回值无关，</p><p><strong>例如1:不同类型，参数顺序不同构成重载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>add(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//调用第二个add 结果hello1</span><br>add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//调用第一个add 结果1hello</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,String b)</span>&#123;<br>System.out.println(a+b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String b,<span class="hljs-type">int</span> a)</span>&#123;<br>System.out.println(a+b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例如2：参数个数不同构成重载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>);<br>add(<span class="hljs-number">8</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>System.out.println(a);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>System.out.println(a+b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例如3：参数类型不同构成重载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>System.out.println(a+b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> a)</span>&#123;<br>System.out.println(a+b);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结:方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p><h3 id="8-3可变参数"><a href="#8-3可变参数" class="headerlink" title="8.3可变参数"></a>8.3可变参数</h3><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法</p><p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声<br>明。</p><p>对于可变参数，编译器会将其转型为一个数组，故在函数内部，可变参数名即可看作数组名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>fn(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(String a,<span class="hljs-type">int</span>... arg)</span>&#123;<br>System.out.println(Arrays.toString(arg));<span class="hljs-comment">//[8,9,10] 所以本质上可变参数就是个数组</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不用可变参数，用数组来写也是同理，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>fn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arg)</span>&#123;<br>System.out.println(Arrays.toString(arg));<span class="hljs-comment">//[8,9,10]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-4递归方法"><a href="#8-4递归方法" class="headerlink" title="8.4递归方法"></a>8.4递归方法</h3><p>所谓的递归就是函数自己调用自己</p><p>求任意数值的阶乘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(fn(<span class="hljs-number">5</span>));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> num*fn(num-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求任意区间数字之和:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(fn(<span class="hljs-number">10</span>));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> num+fn(num-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-修饰符"><a href="#9-修饰符" class="headerlink" title="9.修饰符"></a>9.修饰符</h2><p>Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端</p><p>比如我们前面见到的public static 这都是修饰符</p><h3 id="9-1-访问-x2F-权限修饰符"><a href="#9-1-访问-x2F-权限修饰符" class="headerlink" title="9.1 访问&#x2F;权限修饰符"></a>9.1 访问&#x2F;权限修饰符</h3><p>可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限</p><ul><li>default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><table><thead><tr><th>修饰府</th><th>当前类</th><th>同一包内</th><th>不同包中的子类</th><th>不同包中的非子类</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>关于四种权限修饰符的测试</p><p><strong>1.同一个类内部，四种权限修饰符都可以正常使用</strong></p><p><strong>2.同一个包内部，除了private，其他可以正常使用</strong></p><p><strong>3.非同一个包内的子类中，可以正常使用public和protected</strong>（如果子类跟父类在同一包下，那么除了private，其他也都是可以正常使用的）</p><p><strong>4.非同一个包内非子类中，只有public可以使用</strong></p><h3 id="9-2-非访问修饰符"><a href="#9-2-非访问修饰符" class="headerlink" title="9.2 非访问修饰符"></a>9.2 非访问修饰符</h3><p>static 修饰符，用来修饰类方法和类变量。</p><p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br>abstract 修饰符，用来创建抽象类和抽象方法。</p><p>具体内容见面向对象章节</p><h2 id="10-面向对象"><a href="#10-面向对象" class="headerlink" title="10.面向对象"></a>10.面向对象</h2><h3 id="10-1-类和对象"><a href="#10-1-类和对象" class="headerlink" title="10.1 类和对象"></a>10.1 类和对象</h3><p>Java作为一种面向对象语言。支持以下基本概念：</p><ul><li><p>多态</p></li><li><p>继承</p></li><li><p>封装</p></li><li><p>抽象</p></li><li><p>类</p></li><li><p>对象</p></li><li><p>实例</p></li><li><p>方法</p></li><li><p>重载</p></li><li><p>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p></li><li><p>类：类本质上是一个创建对象的模板，它描述一类对象的行为和状态</p></li></ul><p>编写一个汽车类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-comment">//属性</span><br>String name;<br><span class="hljs-type">int</span> price;<br>String color;<br><span class="hljs-comment">// 方法/行为</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的案例中我们用到了一些属性或者叫变量，还有方法</p><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>Car bmw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>bmw.color=<span class="hljs-string">&quot;red&quot;</span>;<br>bmw.run();<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-comment">//属性也叫成员变量</span><br>String name;<br><span class="hljs-type">int</span> price=<span class="hljs-number">1000000</span>;<br>String color;<br><span class="hljs-comment">// 方法/行为</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;i can run&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者我在Demo1.java文件中定义一个类，在Demo文件中调用也都是没问题的</p><p>例如：</p><p><strong>Demo1.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">int</span> age;<br>String name;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;i can sing&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Demo.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>Person ll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//在这里可以直接调用不同文件的类。因为默认default修饰，同一包内可见</span><br>ll.sing();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-类中的变量"><a href="#10-2-类中的变量" class="headerlink" title="10.2 类中的变量"></a>10.2 类中的变量</h3><ul><li><strong>局部变量：</strong>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> printNumber（）&#123;<br><span class="hljs-type">int</span> a;<span class="hljs-comment">//局部变量</span><br>&#125;<br><span class="hljs-comment">// 其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>成员变量(非静态变量) 相当于前端js中的自有属性：</strong>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-type">int</span> a;<span class="hljs-comment">//成员变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> printNumber（）&#123;<br><span class="hljs-comment">// 其他代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>类变量(静态变量) 相当于前端js中的共有属性：</strong>类变量也声明在类中，方法体之外，但必须声明为static 类型。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;<span class="hljs-comment">//类变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> printNumber（）&#123;<br><span class="hljs-comment">// 其他代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3-封装"><a href="#10-3-封装" class="headerlink" title="10.3 封装"></a>10.3 封装</h3><p>Java 封装，封装意味着将类的属性私有化，提供公共的方法来获取和设置属性</p><p>例如，我们下面的案例，我们定义的Person类，他的属性和方法可以随意在其他类比如Test01类改写，<br>为什么可以被改写，因为默认修饰符default 同一包内都可以访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Person xm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>xm.name=<span class="hljs-string">&quot;小明&quot;</span>;<br>xm.age=<span class="hljs-number">18</span>;<br>xm.intr();<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>String name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">intr</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我叫&quot;</span>+name+<span class="hljs-string">&quot;我今年&quot;</span>+age+<span class="hljs-string">&quot;岁&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何来解决上面的问题呢？很容易想到private，因为private只能在同一类内访问</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Person xm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>xm.setAge(<span class="hljs-number">18</span>);<br>xm.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>System.out.println( xm.getName());<br>System.out.println( xm.getAge());<br>xm.intr();<br>        <br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><span class="hljs-comment">//age=age error</span><br>age = a; <span class="hljs-comment">//注意参数名不能跟属性名重名</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String b)</span> &#123;<br>name = b;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">intr</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我叫&quot;</span>+name+<span class="hljs-string">&quot;我今年&quot;</span>+age+<span class="hljs-string">&quot;岁&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-4-this关键字"><a href="#10-4-this关键字" class="headerlink" title="10.4 this关键字"></a>10.4 this关键字</h3><p>this可以用来修饰</p><p>上面的案例中我们说到了 参数名跟属性名不能重名</p><p>因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>age = age; <span class="hljs-comment">//如果这样写很难区分前后的age分别代表谁，程序会认为等号前后的age都代表参数age</span><br>&#125;<br></code></pre></td></tr></table></figure><p>**解决:**this代表当前对象，注意是当前对象，不是当前类</p><p>在类的方法中，我们可以使用this.属性或者this.方法的方式，调用当前对象的属性或方法，但大多数情<br>况下我们都省略了this。</p><p><strong>单独使用this(),那么this代表构造器</strong><br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Person a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xm&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>Person()&#123;<br>System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br>    Person(String m)&#123;<br><span class="hljs-built_in">this</span>();<span class="hljs-comment">//代表调用自身的构造器</span><br>System.out.println(m);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//xm</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1.在构造器中不能自己调用自己，不然就是一个死循环了</p><p>2.另外，如果想直接调用构造器，调用构造器的代码必须写在第一行</p><p>3.调用构造器只能调用一次</p><h3 id="10-5-构造方法-x2F-构造器"><a href="#10-5-构造方法-x2F-构造器" class="headerlink" title="10.5 构造方法&#x2F;构造器"></a>10.5 构造方法&#x2F;构造器</h3><p>当一个对象被创建时候，构造方法用来初始化该对象。<strong>构造方法和它所在类的名字相同</strong>，但构造方法没有返回值。<br>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。<br>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为protected，构造函数也改为 protected)。<br>一旦你定义了自己的构造方法，默认构造方法就会失效。</p><p>事实上，我们以前new Person()创建一个对象，Person这个函数其实就是构造方法</p><p>对应的，构造函数还可以初始化对象的属性</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Persons xm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Persons</span>(<span class="hljs-number">18</span>);<br>System.out.println(xm.age);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Persons</span>&#123;<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Persons</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>age=a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特殊的，构造器也可以有多个,本质上其实就是方法的重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Persons xm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Persons</span>(<span class="hljs-number">18</span>);<br>Persons ll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Persons</span>(<span class="hljs-string">&quot;李雷&quot;</span>);<br>System.out.println(ll.name);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Persons</span>&#123;<br><span class="hljs-type">int</span> age;<br>String name;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Persons</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>age=a;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Persons</span><span class="hljs-params">(String a)</span>&#123;<br>name=a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-6-package"><a href="#10-6-package" class="headerlink" title="10.6 package"></a>10.6 package</h3><p>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p><p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p><p>同一个包下，不能有重名的类。不同包下，可以有同名的类</p><p><strong>包名其实就是路径名</strong><br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Something</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>那么它的路径应该是 net&#x2F;java&#x2F;util&#x2F;Something.java 这样保存的。 package(包) 的作用是把不同的 java程序分类保存，更方便的被其他 java 程序调用。</p><p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p><p>以下是一些 Java 中的包：</p><ul><li>java.lang-打包基础的类</li><li>java.io-包含输入输出功能的函数</li></ul><p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p><p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p><p><strong>包名的命名规范</strong></p><p>1.包名全部用小写字母</p><h4 id="10-6-1-import"><a href="#10-6-1-import" class="headerlink" title="10.6.1 import"></a>10.6.1 import</h4><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</p><p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p><p><strong>注意： import 声明必须在包声明之后，类声明之前。</strong></p><p>1.如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。也不需要引入<br>所以我们之前很多的包名都没有写</p><p>2.如果需要引入某一个包下的所有结构，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> index.*;<br></code></pre></td></tr></table></figure><p>3.如果引入的多个包，包名相同的情况</p><p>例如目前</p><p>index包下有一个Test.java</p><p>index2包下有一个Test.java</p><p>现在需要在other包下引入两个Test.java，，目前重名肯定不能直接引入</p><p><strong>解决方案：全类名</strong></p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220718143419037.png" alt="image-20220718143419037"></p><h3 id="10-7-继承"><a href="#10-7-继承" class="headerlink" title="10.7 继承"></a>10.7 继承</h3><h4 id="10-7-1-什么叫继承："><a href="#10-7-1-什么叫继承：" class="headerlink" title="10.7.1 什么叫继承："></a>10.7.1 什么叫继承：</h4><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>&#125;<br>class 子类 extends 父类 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-7-2为什么要使用继承"><a href="#10-7-2为什么要使用继承" class="headerlink" title="10.7.2为什么要使用继承"></a>10.7.2为什么要使用继承</h4><p>从已有的类派生出新的类，称为继承。</p><p>在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。</p><p>因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。</p><p>继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。</p><p>例如：车是一个类别，但是现实中有很多车，像车的颜色型号排量价格是每个车都具有的属性，他们本质上都属于车。所以这个时候我们就可以通过继承快速创建子类实例对象</p><p>但是注意，如果父类的属性为private，子类同样是无法访问的</p><h4 id="10-7-3继承的特点"><a href="#10-7-3继承的特点" class="headerlink" title="10.7.3继承的特点"></a>10.7.3继承的特点</h4><p>1.Java只支持单继承，不支持多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个类只能有一个父类，不可以有多个父类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Demo</span>&#123;&#125; <span class="hljs-comment">//ok</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Demo1</span>,Demo2...<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><p>2.Java支持多层（重）继承(继承体系)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>3.子类拥有父类非 private 的属性、方法。</p><p>4.子类可以拥有自己的属性和方法，也可以对父类进行扩展。</p><p>特殊的情况：如果子类自定义的方法和父类的重名，会优先访问子类自己的。这种方式称之为方法的重写</p><p><strong>关于构造器：</strong><br>        子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。<br>        如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p><h3 id="10-8重写-Override-和重载-Overload"><a href="#10-8重写-Override-和重载-Overload" class="headerlink" title="10.8重写(Override)和重载(Overload)"></a>10.8重写(Override)和重载(Overload)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p><p><strong>重写的注意事项</strong></p><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类&#x2F;子类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个类，则不能重写该类的方法。</li></ul><p><strong>重写和重载的区别</strong></p><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h3 id="10-9-super关键字"><a href="#10-9-super关键字" class="headerlink" title="10.9 super关键字"></a>10.9 super关键字</h3><p>super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。<br>如果直接父类找不到，会一直向上找</p><p>super可以修饰：属性、方法、构造器</p><h4 id="10-9-1super的两种用法"><a href="#10-9-1super的两种用法" class="headerlink" title="10.9.1super的两种用法"></a>10.9.1super的两种用法</h4><p><strong>1.普通的直接引用</strong><br>        与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。<br><strong>2.引用构造函数</strong><br>        <strong>super(参数)：</strong>调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>        <strong>this(参数)：</strong>调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。<br>另外子类构造器默认都会调用super()方法，无论你写没写</p><h4 id="10-9-2-super-和-this的异同"><a href="#10-9-2-super-和-this的异同" class="headerlink" title="10.9.2 super 和 this的异同"></a>10.9.2 super 和 this的异同</h4><ul><li>super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）</li><li>this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li><li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名）</li><li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li><li>super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。</li><li>super() 和 this() 均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static方法，static 语句块。</li><li>从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。</li></ul><h3 id="10-10-多态"><a href="#10-10-多态" class="headerlink" title="10.10 多态"></a>10.10 多态</h3><h4 id="10-10-1-什么是多态"><a href="#10-10-1-什么是多态" class="headerlink" title="10.10.1 什么是多态"></a>10.10.1 什么是多态</h4><blockquote><p>多态是同一个行为具有多个不同表现形式或形态的能力。<br>多态就是同一个接口，使用不同的实例而执行不同操作</p></blockquote><p>多态性是对象多种表现形式的体现</p><p><strong>总的来说：同一件事，发生在不同对象身上，就会产生不同的结果</strong></p><p>比如：以前我们声明什么类就需要new 什么类，现在我声明Animal类创建Cat类，也是没错的。相当于用一个更大的范围去修饰一个更具体的对象</p><h4 id="10-10-2多态存在的三个必要条件"><a href="#10-10-2多态存在的三个必要条件" class="headerlink" title="10.10.2多态存在的三个必要条件"></a>10.10.2多态存在的三个必要条件</h4><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：Parent p &#x3D; new Child();</li></ul><h4 id="10-10-3-多态有什么用"><a href="#10-10-3-多态有什么用" class="headerlink" title="10.10.3 多态有什么用"></a>10.10.3 多态有什么用</h4><p>下面是个案例，解释了多态的实际作用<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> other;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>show(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()); <span class="hljs-comment">// 以 Cat 对象调用 show 方法</span><br>show(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()); <span class="hljs-comment">// 以 Dog 对象调用 show 方法</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// 向上转型</span><br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(Animal a)</span> &#123;<br>a.eat();<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的案例中</p><p>如果没有多态：我们需要自己给子类创建方法，才能调用<br>有多态：我们可以直接使用父类定义的方法，子类无需定义就可以使用</p><p>注意：如上代码中，我如果在下图位置加上a.work是否正确</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724125326497.png" alt="image-20220724125326497"></p><p>答案是错误的，不允许的</p><p>因为work是Cat才有的，Animal没有。可能很多人认为多态我们默认调用的不也是子类自己的方法吗，为什么这里不行？</p><p><strong>注意！！！！！！</strong><br><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</strong><br><strong>属性是不具备多态性的，访问属性都是去访问子类自己的属性</strong></p><p>如果必须就是想让a使用work方法，也可以，答案就是使用强制类型转换，如下图</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724125425026.png" alt="image-20220724125425026"></p><h4 id="10-10-4-虚方法"><a href="#10-10-4-虚方法" class="headerlink" title="10.10.4 虚方法"></a>10.10.4 虚方法</h4><p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法 称位虚拟方法，父类根据赋给他的不同的子类对象，动态调用属于子类的该方法，这样的方法调用在编译期是无法确定的。</p><h3 id="10-11-包装类"><a href="#10-11-包装类" class="headerlink" title="10.11 包装类"></a>10.11 包装类</h3><h4 id="10-11-1-基本概念"><a href="#10-11-1-基本概念" class="headerlink" title="10.11.1 基本概念"></a>10.11.1 基本概念</h4><p>包装类产生原因：因为基本数据类型无法进行对象化处理，所以就引入了包装类</p><p>包装类：拥有属性、方法，可以对象化交互</p><p>包装类与基本数据类型对应</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724125524889.png" alt="image-20220724125524889"></p><p>1.Java中数值型包装类都是继承自number类型，都是用final修饰的，不可以继承<br>2.Boolean和character都是继承自Object类</p><h4 id="10-11-2-基本数据类型转为包装类"><a href="#10-11-2-基本数据类型转为包装类" class="headerlink" title="10.11.2 基本数据类型转为包装类"></a>10.11.2 基本数据类型转为包装类</h4><p>基本数据类型转为对应的包装类对象称为装箱。</p><h4 id="10-11-3-包装类转为基本数据类型"><a href="#10-11-3-包装类转为基本数据类型" class="headerlink" title="10.11.3 包装类转为基本数据类型"></a>10.11.3 包装类转为基本数据类型</h4><p>包装类对象转为对应的基本类型称为拆箱。</p><h4 id="10-11-4-自动装箱和自动拆箱"><a href="#10-11-4-自动装箱和自动拆箱" class="headerlink" title="10.11.4 自动装箱和自动拆箱"></a>10.11.4 自动装箱和自动拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//自动装箱：基本数据类型-&gt;包装类</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> num1;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> b1;<br><br>        <span class="hljs-comment">//自动拆箱：包装类-&gt;基本数据类型</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num3</span> <span class="hljs-operator">=</span> num2;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-11-5-基本数据类型、包装类和String类型之间的转换"><a href="#10-11-5-基本数据类型、包装类和String类型之间的转换" class="headerlink" title="10.11.5 基本数据类型、包装类和String类型之间的转换"></a>10.11.5 基本数据类型、包装类和String类型之间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperTest</span> &#123;<br><br>    <span class="hljs-comment">// 基本数据类型、包装类-&gt;String类型</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//方式1：连接运算</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> num1 + <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//方式2：调用String重载的valueOf方法</span><br><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.34f</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> String.valueOf(f1);<br>System.out.println(str2);<br><span class="hljs-type">Double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">12.3</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(d1);<br>System.out.println(str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-11-6-String类型转为基本数据类型、包装类"><a href="#10-11-6-String类型转为基本数据类型、包装类" class="headerlink" title="10.11.6 String类型转为基本数据类型、包装类"></a>10.11.6 String类型转为基本数据类型、包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperTest</span> &#123;<br><span class="hljs-comment">// String类型-&gt;基本数据类型</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(str1);<br>System.out.println(num2);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(str2);<br>System.out.println(b1);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-12-static关键字"><a href="#10-12-static关键字" class="headerlink" title="10.12 static关键字"></a>10.12 static关键字</h3><blockquote><p>“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</p></blockquote><blockquote><p>（相类似于js中的共有属性），但是每个实例对象都可以直接修改静态变量</p></blockquote><p><strong>静态变量：</strong><br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。<br><strong>静态方法：</strong><br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724125948745.png" alt="image-20220724125948745"></p><p><strong>因为静态变量是在对象创建之前就有的</strong><br>所以：<br><strong>1.静态方法中，只能调用静态属性或方法</strong><br><strong>2.对于非静态方法，既可以调用非静态方法和属性也可以调用静态方法和属性</strong><br><strong>所以在使用static的时候，内部不能使用this关键字，super同理也不能使用，因为还没创建对象。</strong></p><h3 id="10-13-代码块"><a href="#10-13-代码块" class="headerlink" title="10.13 代码块"></a>10.13 代码块</h3><p>1.静态代码块</p><blockquote><p>可以有输出语句<br>可以对类的属性声明进行初始化操作<br>不可以对非静态的属性进行初始化。 即不可以调用非静态的属性和方法。<br>若有多个静态的代码块，则按照从上到下的顺序依次执行。<br>静态代码块的执行要先于非静态代码块。<br>静态代码只执行一次。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Per</span> &#123;<br><span class="hljs-keyword">static</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;静态代码块1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">static</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;静态代码块2&quot;</span>);<br>&#125;<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态代码块&quot;</span>);<br>&#125;<br>    Per()<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;per的构造函数&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.非静态代码块</p><blockquote><p>可以有输出语句<br>可以对类的属性声明进行初始化操作<br>可以调用静态或者非静态的变量或方法<br>若有多个非静态的代码块，那么按照从上到下的顺序依次执行<br>再次创建对象的时候都会执行，且先于构造函数执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Per</span> &#123;<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态代码块1&quot;</span>);<br>&#125;<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态代码块2&quot;</span>);<br>&#125;<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态代码块3&quot;</span>);<br>&#125;<br>Per()<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;per的构造函数&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-14-final关键字"><a href="#10-14-final关键字" class="headerlink" title="10.14 final关键字"></a>10.14 final关键字</h3><p><strong>final 变量：</strong><br>final 表示”最后的、最终的”含义。被 final 修饰的实例变量必须显式指定初始值。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><p><strong>1.final可以修饰变量</strong></p><p>变量一旦赋值后，不能被重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 下面是声明常量的实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BOXWIDTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TITLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Manager&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeValue</span><span class="hljs-params">()</span>&#123;<br>value = <span class="hljs-number">12</span>; <span class="hljs-comment">//将输出一个错误</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.final修饰类</strong></p><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-comment">// 类体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.final修饰方法</strong></p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。<br>声明 final 方法的主要目的是防止该方法的内容被修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeName</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 方法体</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.final修饰的成员变量初始化方式</strong></p><p>定义变量时直接赋值<br>在构造器中赋值也可以，但在每个构造器中都需要有赋值语句<br>代码块中也可以完成初始化</p><p><strong>5.final修饰的类变量初始化方式</strong></p><p>定义变量时直接赋值<br>静态代码块中也可以完成初始化</p><h3 id="10-15-抽象类"><a href="#10-15-抽象类" class="headerlink" title="10.15 抽象类"></a>10.15 抽象类</h3><blockquote><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类完全只需要提供一个没有方法体的方法签名即可，具体实现交给子类自己去实现。</p><p><strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。</strong></p></blockquote><blockquote><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p><strong>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</strong>也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></blockquote><p>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类</p><p><strong>1.抽象方法</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表)；<br>如：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>；<br></code></pre></td></tr></table></figure><p><strong>2.抽象类</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名字 &#123;&#125;<br>如<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>；&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象类五大要点</strong></p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象<br>类的非抽象子类可以创建对象。</li></ol><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724153229153.png" alt="image-20220724153229153"></p><p>2.抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。因为只要存在抽象方法，就不能<br>有对象调用，所以如果不是抽象类，就可以创建对象并调用，这是不对的</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724153252660.png" alt="image-20220724153252660"></p><p>3.抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p><p>4.构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p><p>5.抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p><p>如果没有实现就会报错：</p><p>关于抽象类的案例：求各个图形面积</p><h3 id="10-16-接口"><a href="#10-16-接口" class="headerlink" title="10.16 接口"></a>10.16 接口</h3><p>接口（英文：Interface） ：本质上是抽象方法的集合 ，一个类通过继承接口的方式，从而来继承接口<br>的抽象方法。</p><p><strong>1、接口的本质</strong></p><p>普通类：只有具体实现<br>抽象类：具体实现和规范(抽象方法) 都有！<br>接口：只有规范！</p><p>抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。</p><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。<br>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p>接口声明的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[可见度] interface 接口名称 [extends 其他的接口名] &#123;<br><span class="hljs-comment">// 声明变量</span><br><span class="hljs-comment">// 抽象方法</span><br>&#125;<br>例如<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口实现的语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MammalInt</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Mammal eats&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Mammal travels&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">noOfLegs</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br><span class="hljs-type">MammalInt</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MammalInt</span>();<br>m.eat();<br>m.travel();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口的特性</strong></p><p>**1.**接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public<br>abstract，其他修饰符都会报错）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//默认就是public abstract修饰的</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**2.**接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是public，用 private 修饰会报编译错误）。</p><blockquote><p>注:可以直接使用接口名访问其属性。因为是public static修饰的<br>注:声明的同时就必须赋值.(因为接口中不能编写静态代码块)</p></blockquote><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724153739722.png" alt="image-20220724153739722"></p><p>**3.**接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。<br>**4.**一个类可以实现多个接口<br>**5.**如果继承和实现接口同时存在，先继承，再实现<br>**6.**接口与接口之间可以继承，并且可以是多继承</p><p>接口的多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hockey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sports</span>, Event<br></code></pre></td></tr></table></figure><h3 id="10-17-内部类"><a href="#10-17-内部类" class="headerlink" title="10.17 内部类"></a>10.17 内部类</h3><p>概念：</p><blockquote><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p></blockquote><h4 id="10-17-1-成员内部类"><a href="#10-17-1-成员内部类" class="headerlink" title="10.17.1 成员内部类"></a>10.17.1 成员内部类</h4><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br><span class="hljs-built_in">this</span>.radius = radius;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123; <span class="hljs-comment">//成员内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//实例化Draw</span><br></code></pre></td></tr></table></figure><p>实例化内部类: 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是<br>必须存在一个外部类的对象</p><p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类<br>的所有成员属性和成员方法（包括private成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br><span class="hljs-built_in">this</span>.radius = radius;<br>&#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123; <span class="hljs-comment">//内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>System.out.println(radius); <span class="hljs-comment">//外部类的private成员</span><br>System.out.println(count); <span class="hljs-comment">//外部类的静态成员</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情<br>况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-built_in">this</span>.成员变量<br>外部类.<span class="hljs-built_in">this</span>.成员方法<br></code></pre></td></tr></table></figure><p><strong>并且内部类可以被四种权限修饰符修饰，不同于之前只有default 和public修饰</strong></p><blockquote><p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Draw 用 private 修饰，则只能在外部类的内部访问，如果用 public修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p></blockquote><h4 id="10-17-2-静态内部类"><a href="#10-17-2-静态内部类" class="headerlink" title="10.17.2 静态内部类"></a>10.17.2 静态内部类</h4><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>.Inner();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Outter</span><span class="hljs-params">()</span> &#123;<br>        <br>&#125;<br><span class="hljs-comment">//静态内部类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner</span><span class="hljs-params">()</span> &#123;<br>            <br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724111724697.png" alt="image-20220724111724697"></p><h4 id="10-17-3-局部内部类"><a href="#10-17-3-局部内部类" class="headerlink" title="10.17.3 局部内部类"></a>10.17.3 局部内部类</h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">()</span> &#123;<br>        <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Man</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> People <span class="hljs-title function_">getWoman</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123; <span class="hljs-comment">//局部内部类</span><br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static<br>修饰符的。</p><h4 id="10-17-4-匿名内部类"><a href="#10-17-4-匿名内部类" class="headerlink" title="10.17.4 匿名内部类"></a>10.17.4 匿名内部类</h4><p>就是内部类的简化写法</p><p>**前提:**存在一个类或者接口(这里的类可以是具体类也可以是抽象类)</p><p><strong>格式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或者接口名() &#123;<br>重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><p>**本质是:**一个继承了该类或者是实现了该接口的子类匿名对象</p><p><img src="/./JAVA%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/image-20220724112113592.png" alt="image-20220724112113592"></p><h3 id="10-18-枚举"><a href="#10-18-枚举" class="headerlink" title="10.18 枚举"></a>10.18 枚举</h3><blockquote><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类</p></blockquote><p>首先我们不用枚举类型，也可以，我们可以采用如下写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//未采用枚举类型的写法</span><br>System.out.println(Test.boy);<br>System.out.println(Test.girl);<br><span class="hljs-comment">//采用枚举类型的写法</span><br>System.out.println(Gender.BOY);<br>System.out.println(Gender.GIRL);<br>&#125;<br>&#125;<br><span class="hljs-comment">//未采用枚举类型的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//采用枚举类型的写法</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;<br>BOY,GIRL<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span><br>&#123;<br>RED, GREEN, BLUE;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-comment">// 执行输出结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">Color</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Color.RED;<br>System.out.println(c1);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明在类内部也是可以的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> index2;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span><br>&#123;<br>RED, GREEN, BLUE;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Color c=Color.BLUE;<br>System.out.println(c);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>values(), ordinal() 和 valueOf() 方法</p><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和java.lang.Comparable 两个接口。</p><p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li>values() 返回枚举类中所有的值。</li><li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li><li>valueOf()方法返回指定字符串值的枚举常量。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/22/hello-world/"/>
    <url>/2023/04/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
